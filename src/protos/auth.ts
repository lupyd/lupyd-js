// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.31.1
// source: auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "lupyd.auth";

export interface UserTokens {
  accessToken: string;
  refreshToken: string;
}

export interface TokenRequest {
  appId: string;
  permissions: number;
  refreshToken: string;
}

export interface NewAppRequest {
  appId: string;
  contactEmail: string;
  appLink?: string | undefined;
  permisisons?: number | undefined;
}

export interface NewLoginThirdPartyRequest {
  app: string;
  tpAppId: string;
}

export interface ThirdPartyLoginResponse {
  lupydTokens: UserTokens | undefined;
  appTokens: UserTokens | undefined;
}

export interface LoggedInApp {
  app: string;
  aud: string;
  loggedInSince: bigint;
  lastTokenRefresh: bigint;
}

export interface LoggedInApps {
  apps: LoggedInApp[];
}

export interface LogoutToken {
  token: string;
}

export interface LogoutTokens {
  tokens: LogoutToken[];
}

function createBaseUserTokens(): UserTokens {
  return { accessToken: "", refreshToken: "" };
}

export const UserTokens: MessageFns<UserTokens> = {
  encode(message: UserTokens, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserTokens {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserTokens {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: UserTokens): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserTokens>, I>>(base?: I): UserTokens {
    return UserTokens.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserTokens>, I>>(object: I): UserTokens {
    const message = createBaseUserTokens();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseTokenRequest(): TokenRequest {
  return { appId: "", permissions: 0, refreshToken: "" };
}

export const TokenRequest: MessageFns<TokenRequest> = {
  encode(message: TokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.permissions !== 0) {
      writer.uint32(16).uint32(message.permissions);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.permissions = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenRequest {
    return {
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: TokenRequest): unknown {
    const obj: any = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.permissions !== 0) {
      obj.permissions = Math.round(message.permissions);
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenRequest>, I>>(base?: I): TokenRequest {
    return TokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenRequest>, I>>(object: I): TokenRequest {
    const message = createBaseTokenRequest();
    message.appId = object.appId ?? "";
    message.permissions = object.permissions ?? 0;
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseNewAppRequest(): NewAppRequest {
  return { appId: "", contactEmail: "", appLink: undefined, permisisons: undefined };
}

export const NewAppRequest: MessageFns<NewAppRequest> = {
  encode(message: NewAppRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.contactEmail !== "") {
      writer.uint32(18).string(message.contactEmail);
    }
    if (message.appLink !== undefined) {
      writer.uint32(26).string(message.appLink);
    }
    if (message.permisisons !== undefined) {
      writer.uint32(32).uint32(message.permisisons);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewAppRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewAppRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contactEmail = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appLink = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.permisisons = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewAppRequest {
    return {
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      contactEmail: isSet(object.contactEmail) ? globalThis.String(object.contactEmail) : "",
      appLink: isSet(object.appLink) ? globalThis.String(object.appLink) : undefined,
      permisisons: isSet(object.permisisons) ? globalThis.Number(object.permisisons) : undefined,
    };
  },

  toJSON(message: NewAppRequest): unknown {
    const obj: any = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.contactEmail !== "") {
      obj.contactEmail = message.contactEmail;
    }
    if (message.appLink !== undefined) {
      obj.appLink = message.appLink;
    }
    if (message.permisisons !== undefined) {
      obj.permisisons = Math.round(message.permisisons);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewAppRequest>, I>>(base?: I): NewAppRequest {
    return NewAppRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewAppRequest>, I>>(object: I): NewAppRequest {
    const message = createBaseNewAppRequest();
    message.appId = object.appId ?? "";
    message.contactEmail = object.contactEmail ?? "";
    message.appLink = object.appLink ?? undefined;
    message.permisisons = object.permisisons ?? undefined;
    return message;
  },
};

function createBaseNewLoginThirdPartyRequest(): NewLoginThirdPartyRequest {
  return { app: "", tpAppId: "" };
}

export const NewLoginThirdPartyRequest: MessageFns<NewLoginThirdPartyRequest> = {
  encode(message: NewLoginThirdPartyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.app !== "") {
      writer.uint32(10).string(message.app);
    }
    if (message.tpAppId !== "") {
      writer.uint32(18).string(message.tpAppId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewLoginThirdPartyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewLoginThirdPartyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.app = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tpAppId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewLoginThirdPartyRequest {
    return {
      app: isSet(object.app) ? globalThis.String(object.app) : "",
      tpAppId: isSet(object.tpAppId) ? globalThis.String(object.tpAppId) : "",
    };
  },

  toJSON(message: NewLoginThirdPartyRequest): unknown {
    const obj: any = {};
    if (message.app !== "") {
      obj.app = message.app;
    }
    if (message.tpAppId !== "") {
      obj.tpAppId = message.tpAppId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewLoginThirdPartyRequest>, I>>(base?: I): NewLoginThirdPartyRequest {
    return NewLoginThirdPartyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewLoginThirdPartyRequest>, I>>(object: I): NewLoginThirdPartyRequest {
    const message = createBaseNewLoginThirdPartyRequest();
    message.app = object.app ?? "";
    message.tpAppId = object.tpAppId ?? "";
    return message;
  },
};

function createBaseThirdPartyLoginResponse(): ThirdPartyLoginResponse {
  return { lupydTokens: undefined, appTokens: undefined };
}

export const ThirdPartyLoginResponse: MessageFns<ThirdPartyLoginResponse> = {
  encode(message: ThirdPartyLoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lupydTokens !== undefined) {
      UserTokens.encode(message.lupydTokens, writer.uint32(10).fork()).join();
    }
    if (message.appTokens !== undefined) {
      UserTokens.encode(message.appTokens, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThirdPartyLoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThirdPartyLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lupydTokens = UserTokens.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appTokens = UserTokens.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThirdPartyLoginResponse {
    return {
      lupydTokens: isSet(object.lupydTokens) ? UserTokens.fromJSON(object.lupydTokens) : undefined,
      appTokens: isSet(object.appTokens) ? UserTokens.fromJSON(object.appTokens) : undefined,
    };
  },

  toJSON(message: ThirdPartyLoginResponse): unknown {
    const obj: any = {};
    if (message.lupydTokens !== undefined) {
      obj.lupydTokens = UserTokens.toJSON(message.lupydTokens);
    }
    if (message.appTokens !== undefined) {
      obj.appTokens = UserTokens.toJSON(message.appTokens);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ThirdPartyLoginResponse>, I>>(base?: I): ThirdPartyLoginResponse {
    return ThirdPartyLoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ThirdPartyLoginResponse>, I>>(object: I): ThirdPartyLoginResponse {
    const message = createBaseThirdPartyLoginResponse();
    message.lupydTokens = (object.lupydTokens !== undefined && object.lupydTokens !== null)
      ? UserTokens.fromPartial(object.lupydTokens)
      : undefined;
    message.appTokens = (object.appTokens !== undefined && object.appTokens !== null)
      ? UserTokens.fromPartial(object.appTokens)
      : undefined;
    return message;
  },
};

function createBaseLoggedInApp(): LoggedInApp {
  return { app: "", aud: "", loggedInSince: 0n, lastTokenRefresh: 0n };
}

export const LoggedInApp: MessageFns<LoggedInApp> = {
  encode(message: LoggedInApp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.app !== "") {
      writer.uint32(10).string(message.app);
    }
    if (message.aud !== "") {
      writer.uint32(18).string(message.aud);
    }
    if (message.loggedInSince !== 0n) {
      if (BigInt.asUintN(64, message.loggedInSince) !== message.loggedInSince) {
        throw new globalThis.Error("value provided for field message.loggedInSince of type uint64 too large");
      }
      writer.uint32(24).uint64(message.loggedInSince);
    }
    if (message.lastTokenRefresh !== 0n) {
      if (BigInt.asUintN(64, message.lastTokenRefresh) !== message.lastTokenRefresh) {
        throw new globalThis.Error("value provided for field message.lastTokenRefresh of type uint64 too large");
      }
      writer.uint32(32).uint64(message.lastTokenRefresh);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggedInApp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedInApp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.app = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aud = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.loggedInSince = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastTokenRefresh = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggedInApp {
    return {
      app: isSet(object.app) ? globalThis.String(object.app) : "",
      aud: isSet(object.aud) ? globalThis.String(object.aud) : "",
      loggedInSince: isSet(object.loggedInSince) ? BigInt(object.loggedInSince) : 0n,
      lastTokenRefresh: isSet(object.lastTokenRefresh) ? BigInt(object.lastTokenRefresh) : 0n,
    };
  },

  toJSON(message: LoggedInApp): unknown {
    const obj: any = {};
    if (message.app !== "") {
      obj.app = message.app;
    }
    if (message.aud !== "") {
      obj.aud = message.aud;
    }
    if (message.loggedInSince !== 0n) {
      obj.loggedInSince = message.loggedInSince.toString();
    }
    if (message.lastTokenRefresh !== 0n) {
      obj.lastTokenRefresh = message.lastTokenRefresh.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoggedInApp>, I>>(base?: I): LoggedInApp {
    return LoggedInApp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoggedInApp>, I>>(object: I): LoggedInApp {
    const message = createBaseLoggedInApp();
    message.app = object.app ?? "";
    message.aud = object.aud ?? "";
    message.loggedInSince = object.loggedInSince ?? 0n;
    message.lastTokenRefresh = object.lastTokenRefresh ?? 0n;
    return message;
  },
};

function createBaseLoggedInApps(): LoggedInApps {
  return { apps: [] };
}

export const LoggedInApps: MessageFns<LoggedInApps> = {
  encode(message: LoggedInApps, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.apps) {
      LoggedInApp.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggedInApps {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedInApps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apps.push(LoggedInApp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggedInApps {
    return { apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e: any) => LoggedInApp.fromJSON(e)) : [] };
  },

  toJSON(message: LoggedInApps): unknown {
    const obj: any = {};
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => LoggedInApp.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoggedInApps>, I>>(base?: I): LoggedInApps {
    return LoggedInApps.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoggedInApps>, I>>(object: I): LoggedInApps {
    const message = createBaseLoggedInApps();
    message.apps = object.apps?.map((e) => LoggedInApp.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLogoutToken(): LogoutToken {
  return { token: "" };
}

export const LogoutToken: MessageFns<LogoutToken> = {
  encode(message: LogoutToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutToken {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: LogoutToken): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutToken>, I>>(base?: I): LogoutToken {
    return LogoutToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutToken>, I>>(object: I): LogoutToken {
    const message = createBaseLogoutToken();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseLogoutTokens(): LogoutTokens {
  return { tokens: [] };
}

export const LogoutTokens: MessageFns<LogoutTokens> = {
  encode(message: LogoutTokens, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokens) {
      LogoutToken.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutTokens {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokens.push(LogoutToken.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutTokens {
    return {
      tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e: any) => LogoutToken.fromJSON(e)) : [],
    };
  },

  toJSON(message: LogoutTokens): unknown {
    const obj: any = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => LogoutToken.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutTokens>, I>>(base?: I): LogoutTokens {
    return LogoutTokens.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutTokens>, I>>(object: I): LogoutTokens {
    const message = createBaseLogoutTokens();
    message.tokens = object.tokens?.map((e) => LogoutToken.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
