"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.31.1
// source: post.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostHashtags = exports.PostHashtag = exports.PostReport = exports.PollUserVotes = exports.PollUserVote = exports.CreatePollFields = exports.PollResults = exports.PollResult = exports.PollOption = exports.PollVote = exports.CreateFileFields = exports.PostIds = exports.Vote = exports.Votes = exports.FullPosts = exports.GetPostsData = exports.File = exports.CreatePostWithFiles = exports.CreatePostDetails = exports.FullPost = exports.PostBodies = exports.PostBody = exports.BoolValue = exports.postType = exports.protobufPackage = void 0;
exports.postTypeFromJSON = postTypeFromJSON;
exports.postTypeToJSON = postTypeToJSON;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const lupyd_md_1 = require("./lupyd-md");
exports.protobufPackage = "lupyd.post";
var postType;
(function (postType) {
    postType[postType["NOT_DEFINED"] = 0] = "NOT_DEFINED";
    postType[postType["SAFE"] = 1] = "SAFE";
    postType[postType["ANONYMOUS"] = 2] = "ANONYMOUS";
    postType[postType["NSFW"] = 4] = "NSFW";
    postType[postType["DANGEROUS"] = 8] = "DANGEROUS";
    postType[postType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(postType || (exports.postType = postType = {}));
function postTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "NOT_DEFINED":
            return postType.NOT_DEFINED;
        case 1:
        case "SAFE":
            return postType.SAFE;
        case 2:
        case "ANONYMOUS":
            return postType.ANONYMOUS;
        case 4:
        case "NSFW":
            return postType.NSFW;
        case 8:
        case "DANGEROUS":
            return postType.DANGEROUS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return postType.UNRECOGNIZED;
    }
}
function postTypeToJSON(object) {
    switch (object) {
        case postType.NOT_DEFINED:
            return "NOT_DEFINED";
        case postType.SAFE:
            return "SAFE";
        case postType.ANONYMOUS:
            return "ANONYMOUS";
        case postType.NSFW:
            return "NSFW";
        case postType.DANGEROUS:
            return "DANGEROUS";
        case postType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseBoolValue() {
    return { val: false };
}
exports.BoolValue = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.val !== false) {
            writer.uint32(8).bool(message.val);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBoolValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.val = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { val: isSet(object.val) ? globalThis.Boolean(object.val) : false };
    },
    toJSON(message) {
        const obj = {};
        if (message.val !== false) {
            obj.val = message.val;
        }
        return obj;
    },
    create(base) {
        return exports.BoolValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBoolValue();
        message.val = object.val ?? false;
        return message;
    },
};
function createBasePostBody() {
    return { plainText: undefined, markdown: undefined, elements: undefined };
}
exports.PostBody = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.plainText !== undefined) {
            writer.uint32(10).string(message.plainText);
        }
        if (message.markdown !== undefined) {
            writer.uint32(18).string(message.markdown);
        }
        if (message.elements !== undefined) {
            lupyd_md_1.Elements.encode(message.elements, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostBody();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.plainText = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.markdown = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.elements = lupyd_md_1.Elements.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            plainText: isSet(object.plainText) ? globalThis.String(object.plainText) : undefined,
            markdown: isSet(object.markdown) ? globalThis.String(object.markdown) : undefined,
            elements: isSet(object.elements) ? lupyd_md_1.Elements.fromJSON(object.elements) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.plainText !== undefined) {
            obj.plainText = message.plainText;
        }
        if (message.markdown !== undefined) {
            obj.markdown = message.markdown;
        }
        if (message.elements !== undefined) {
            obj.elements = lupyd_md_1.Elements.toJSON(message.elements);
        }
        return obj;
    },
    create(base) {
        return exports.PostBody.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostBody();
        message.plainText = object.plainText ?? undefined;
        message.markdown = object.markdown ?? undefined;
        message.elements = (object.elements !== undefined && object.elements !== null)
            ? lupyd_md_1.Elements.fromPartial(object.elements)
            : undefined;
        return message;
    },
};
function createBasePostBodies() {
    return { bodies: [] };
}
exports.PostBodies = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.bodies) {
            exports.PostBody.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostBodies();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.bodies.push(exports.PostBody.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bodies: globalThis.Array.isArray(object?.bodies) ? object.bodies.map((e) => exports.PostBody.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bodies?.length) {
            obj.bodies = message.bodies.map((e) => exports.PostBody.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.PostBodies.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostBodies();
        message.bodies = object.bodies?.map((e) => exports.PostBody.fromPartial(e)) || [];
        return message;
    },
};
function createBaseFullPost() {
    return {
        id: new Uint8Array(0),
        title: "",
        by: "",
        postType: 0,
        expiry: 0n,
        replyingTo: new Uint8Array(0),
        body: new Uint8Array(0),
        replies: 0n,
        upvotes: 0n,
        downvotes: 0n,
        isMemory: false,
        vote: undefined,
    };
}
exports.FullPost = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id.length !== 0) {
            writer.uint32(10).bytes(message.id);
        }
        if (message.title !== "") {
            writer.uint32(18).string(message.title);
        }
        if (message.by !== "") {
            writer.uint32(26).string(message.by);
        }
        if (message.postType !== 0) {
            writer.uint32(32).uint32(message.postType);
        }
        if (message.expiry !== 0n) {
            if (BigInt.asUintN(64, message.expiry) !== message.expiry) {
                throw new globalThis.Error("value provided for field message.expiry of type uint64 too large");
            }
            writer.uint32(40).uint64(message.expiry);
        }
        if (message.replyingTo.length !== 0) {
            writer.uint32(50).bytes(message.replyingTo);
        }
        if (message.body.length !== 0) {
            writer.uint32(66).bytes(message.body);
        }
        if (message.replies !== 0n) {
            if (BigInt.asUintN(64, message.replies) !== message.replies) {
                throw new globalThis.Error("value provided for field message.replies of type uint64 too large");
            }
            writer.uint32(72).uint64(message.replies);
        }
        if (message.upvotes !== 0n) {
            if (BigInt.asIntN(64, message.upvotes) !== message.upvotes) {
                throw new globalThis.Error("value provided for field message.upvotes of type int64 too large");
            }
            writer.uint32(80).int64(message.upvotes);
        }
        if (message.downvotes !== 0n) {
            if (BigInt.asIntN(64, message.downvotes) !== message.downvotes) {
                throw new globalThis.Error("value provided for field message.downvotes of type int64 too large");
            }
            writer.uint32(88).int64(message.downvotes);
        }
        if (message.isMemory !== false) {
            writer.uint32(96).bool(message.isMemory);
        }
        if (message.vote !== undefined) {
            exports.BoolValue.encode(message.vote, writer.uint32(106).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullPost();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.by = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.postType = reader.uint32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.expiry = reader.uint64();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.replyingTo = reader.bytes();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.body = reader.bytes();
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.replies = reader.uint64();
                    continue;
                }
                case 10: {
                    if (tag !== 80) {
                        break;
                    }
                    message.upvotes = reader.int64();
                    continue;
                }
                case 11: {
                    if (tag !== 88) {
                        break;
                    }
                    message.downvotes = reader.int64();
                    continue;
                }
                case 12: {
                    if (tag !== 96) {
                        break;
                    }
                    message.isMemory = reader.bool();
                    continue;
                }
                case 13: {
                    if (tag !== 106) {
                        break;
                    }
                    message.vote = exports.BoolValue.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
            title: isSet(object.title) ? globalThis.String(object.title) : "",
            by: isSet(object.by) ? globalThis.String(object.by) : "",
            postType: isSet(object.postType) ? globalThis.Number(object.postType) : 0,
            expiry: isSet(object.expiry) ? BigInt(object.expiry) : 0n,
            replyingTo: isSet(object.replyingTo) ? bytesFromBase64(object.replyingTo) : new Uint8Array(0),
            body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
            replies: isSet(object.replies) ? BigInt(object.replies) : 0n,
            upvotes: isSet(object.upvotes) ? BigInt(object.upvotes) : 0n,
            downvotes: isSet(object.downvotes) ? BigInt(object.downvotes) : 0n,
            isMemory: isSet(object.isMemory) ? globalThis.Boolean(object.isMemory) : false,
            vote: isSet(object.vote) ? exports.BoolValue.fromJSON(object.vote) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id.length !== 0) {
            obj.id = base64FromBytes(message.id);
        }
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.by !== "") {
            obj.by = message.by;
        }
        if (message.postType !== 0) {
            obj.postType = Math.round(message.postType);
        }
        if (message.expiry !== 0n) {
            obj.expiry = message.expiry.toString();
        }
        if (message.replyingTo.length !== 0) {
            obj.replyingTo = base64FromBytes(message.replyingTo);
        }
        if (message.body.length !== 0) {
            obj.body = base64FromBytes(message.body);
        }
        if (message.replies !== 0n) {
            obj.replies = message.replies.toString();
        }
        if (message.upvotes !== 0n) {
            obj.upvotes = message.upvotes.toString();
        }
        if (message.downvotes !== 0n) {
            obj.downvotes = message.downvotes.toString();
        }
        if (message.isMemory !== false) {
            obj.isMemory = message.isMemory;
        }
        if (message.vote !== undefined) {
            obj.vote = exports.BoolValue.toJSON(message.vote);
        }
        return obj;
    },
    create(base) {
        return exports.FullPost.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFullPost();
        message.id = object.id ?? new Uint8Array(0);
        message.title = object.title ?? "";
        message.by = object.by ?? "";
        message.postType = object.postType ?? 0;
        message.expiry = object.expiry ?? 0n;
        message.replyingTo = object.replyingTo ?? new Uint8Array(0);
        message.body = object.body ?? new Uint8Array(0);
        message.replies = object.replies ?? 0n;
        message.upvotes = object.upvotes ?? 0n;
        message.downvotes = object.downvotes ?? 0n;
        message.isMemory = object.isMemory ?? false;
        message.vote = (object.vote !== undefined && object.vote !== null) ? exports.BoolValue.fromPartial(object.vote) : undefined;
        return message;
    },
};
function createBaseCreatePostDetails() {
    return {
        title: "",
        body: undefined,
        expiry: 0n,
        postType: 0,
        isMemory: false,
        replyingTo: new Uint8Array(0),
        files: [],
        editingFrom: new Uint8Array(0),
    };
}
exports.CreatePostDetails = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.body !== undefined) {
            exports.PostBody.encode(message.body, writer.uint32(18).fork()).join();
        }
        if (message.expiry !== 0n) {
            if (BigInt.asUintN(64, message.expiry) !== message.expiry) {
                throw new globalThis.Error("value provided for field message.expiry of type uint64 too large");
            }
            writer.uint32(24).uint64(message.expiry);
        }
        if (message.postType !== 0) {
            writer.uint32(32).int32(message.postType);
        }
        if (message.isMemory !== false) {
            writer.uint32(40).bool(message.isMemory);
        }
        if (message.replyingTo.length !== 0) {
            writer.uint32(50).bytes(message.replyingTo);
        }
        for (const v of message.files) {
            writer.uint32(58).string(v);
        }
        if (message.editingFrom.length !== 0) {
            writer.uint32(66).bytes(message.editingFrom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreatePostDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.body = exports.PostBody.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.expiry = reader.uint64();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.postType = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.isMemory = reader.bool();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.replyingTo = reader.bytes();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.files.push(reader.string());
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.editingFrom = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet(object.title) ? globalThis.String(object.title) : "",
            body: isSet(object.body) ? exports.PostBody.fromJSON(object.body) : undefined,
            expiry: isSet(object.expiry) ? BigInt(object.expiry) : 0n,
            postType: isSet(object.postType) ? globalThis.Number(object.postType) : 0,
            isMemory: isSet(object.isMemory) ? globalThis.Boolean(object.isMemory) : false,
            replyingTo: isSet(object.replyingTo) ? bytesFromBase64(object.replyingTo) : new Uint8Array(0),
            files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => globalThis.String(e)) : [],
            editingFrom: isSet(object.editingFrom) ? bytesFromBase64(object.editingFrom) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.body !== undefined) {
            obj.body = exports.PostBody.toJSON(message.body);
        }
        if (message.expiry !== 0n) {
            obj.expiry = message.expiry.toString();
        }
        if (message.postType !== 0) {
            obj.postType = Math.round(message.postType);
        }
        if (message.isMemory !== false) {
            obj.isMemory = message.isMemory;
        }
        if (message.replyingTo.length !== 0) {
            obj.replyingTo = base64FromBytes(message.replyingTo);
        }
        if (message.files?.length) {
            obj.files = message.files;
        }
        if (message.editingFrom.length !== 0) {
            obj.editingFrom = base64FromBytes(message.editingFrom);
        }
        return obj;
    },
    create(base) {
        return exports.CreatePostDetails.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreatePostDetails();
        message.title = object.title ?? "";
        message.body = (object.body !== undefined && object.body !== null) ? exports.PostBody.fromPartial(object.body) : undefined;
        message.expiry = object.expiry ?? 0n;
        message.postType = object.postType ?? 0;
        message.isMemory = object.isMemory ?? false;
        message.replyingTo = object.replyingTo ?? new Uint8Array(0);
        message.files = object.files?.map((e) => e) || [];
        message.editingFrom = object.editingFrom ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCreatePostWithFiles() {
    return { fields: undefined, files: [] };
}
exports.CreatePostWithFiles = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fields !== undefined) {
            exports.CreatePostDetails.encode(message.fields, writer.uint32(10).fork()).join();
        }
        for (const v of message.files) {
            exports.File.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreatePostWithFiles();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.fields = exports.CreatePostDetails.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.files.push(exports.File.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            fields: isSet(object.fields) ? exports.CreatePostDetails.fromJSON(object.fields) : undefined,
            files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => exports.File.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.fields !== undefined) {
            obj.fields = exports.CreatePostDetails.toJSON(message.fields);
        }
        if (message.files?.length) {
            obj.files = message.files.map((e) => exports.File.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.CreatePostWithFiles.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreatePostWithFiles();
        message.fields = (object.fields !== undefined && object.fields !== null)
            ? exports.CreatePostDetails.fromPartial(object.fields)
            : undefined;
        message.files = object.files?.map((e) => exports.File.fromPartial(e)) || [];
        return message;
    },
};
function createBaseFile() {
    return { name: "", mimeType: "", length: 0n };
}
exports.File = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.mimeType !== "") {
            writer.uint32(18).string(message.mimeType);
        }
        if (message.length !== 0n) {
            if (BigInt.asUintN(64, message.length) !== message.length) {
                throw new globalThis.Error("value provided for field message.length of type uint64 too large");
            }
            writer.uint32(24).uint64(message.length);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.mimeType = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.length = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
            length: isSet(object.length) ? BigInt(object.length) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.mimeType !== "") {
            obj.mimeType = message.mimeType;
        }
        if (message.length !== 0n) {
            obj.length = message.length.toString();
        }
        return obj;
    },
    create(base) {
        return exports.File.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFile();
        message.name = object.name ?? "";
        message.mimeType = object.mimeType ?? "";
        message.length = object.length ?? 0n;
        return message;
    },
};
function createBaseGetPostsData() {
    return { allowedPostTypes: 0, by: [], allPosts: false, cursor: new Uint8Array(0), tags: "" };
}
exports.GetPostsData = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.allowedPostTypes !== 0) {
            writer.uint32(8).uint32(message.allowedPostTypes);
        }
        for (const v of message.by) {
            writer.uint32(18).string(v);
        }
        if (message.allPosts !== false) {
            writer.uint32(24).bool(message.allPosts);
        }
        if (message.cursor.length !== 0) {
            writer.uint32(34).bytes(message.cursor);
        }
        if (message.tags !== "") {
            writer.uint32(42).string(message.tags);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPostsData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.allowedPostTypes = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.by.push(reader.string());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.allPosts = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.cursor = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.tags = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            allowedPostTypes: isSet(object.allowedPostTypes) ? globalThis.Number(object.allowedPostTypes) : 0,
            by: globalThis.Array.isArray(object?.by) ? object.by.map((e) => globalThis.String(e)) : [],
            allPosts: isSet(object.allPosts) ? globalThis.Boolean(object.allPosts) : false,
            cursor: isSet(object.cursor) ? bytesFromBase64(object.cursor) : new Uint8Array(0),
            tags: isSet(object.tags) ? globalThis.String(object.tags) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.allowedPostTypes !== 0) {
            obj.allowedPostTypes = Math.round(message.allowedPostTypes);
        }
        if (message.by?.length) {
            obj.by = message.by;
        }
        if (message.allPosts !== false) {
            obj.allPosts = message.allPosts;
        }
        if (message.cursor.length !== 0) {
            obj.cursor = base64FromBytes(message.cursor);
        }
        if (message.tags !== "") {
            obj.tags = message.tags;
        }
        return obj;
    },
    create(base) {
        return exports.GetPostsData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetPostsData();
        message.allowedPostTypes = object.allowedPostTypes ?? 0;
        message.by = object.by?.map((e) => e) || [];
        message.allPosts = object.allPosts ?? false;
        message.cursor = object.cursor ?? new Uint8Array(0);
        message.tags = object.tags ?? "";
        return message;
    },
};
function createBaseFullPosts() {
    return { posts: [] };
}
exports.FullPosts = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.posts) {
            exports.FullPost.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullPosts();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.posts.push(exports.FullPost.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { posts: globalThis.Array.isArray(object?.posts) ? object.posts.map((e) => exports.FullPost.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.posts?.length) {
            obj.posts = message.posts.map((e) => exports.FullPost.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.FullPosts.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFullPosts();
        message.posts = object.posts?.map((e) => exports.FullPost.fromPartial(e)) || [];
        return message;
    },
};
function createBaseVotes() {
    return { votes: [] };
}
exports.Votes = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.votes) {
            exports.Vote.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVotes();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.votes.push(exports.Vote.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { votes: globalThis.Array.isArray(object?.votes) ? object.votes.map((e) => exports.Vote.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.votes?.length) {
            obj.votes = message.votes.map((e) => exports.Vote.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Votes.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVotes();
        message.votes = object.votes?.map((e) => exports.Vote.fromPartial(e)) || [];
        return message;
    },
};
function createBaseVote() {
    return { id: new Uint8Array(0), val: undefined };
}
exports.Vote = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id.length !== 0) {
            writer.uint32(10).bytes(message.id);
        }
        if (message.val !== undefined) {
            exports.BoolValue.encode(message.val, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.val = exports.BoolValue.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
            val: isSet(object.val) ? exports.BoolValue.fromJSON(object.val) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id.length !== 0) {
            obj.id = base64FromBytes(message.id);
        }
        if (message.val !== undefined) {
            obj.val = exports.BoolValue.toJSON(message.val);
        }
        return obj;
    },
    create(base) {
        return exports.Vote.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVote();
        message.id = object.id ?? new Uint8Array(0);
        message.val = (object.val !== undefined && object.val !== null) ? exports.BoolValue.fromPartial(object.val) : undefined;
        return message;
    },
};
function createBasePostIds() {
    return { ids: [] };
}
exports.PostIds = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.ids) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostIds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ids.push(reader.bytes());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => bytesFromBase64(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => base64FromBytes(e));
        }
        return obj;
    },
    create(base) {
        return exports.PostIds.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostIds();
        message.ids = object.ids?.map((e) => e) || [];
        return message;
    },
};
function createBaseCreateFileFields() {
    return { expiry: 0n, by: "", files: [] };
}
exports.CreateFileFields = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.expiry !== 0n) {
            if (BigInt.asUintN(64, message.expiry) !== message.expiry) {
                throw new globalThis.Error("value provided for field message.expiry of type uint64 too large");
            }
            writer.uint32(8).uint64(message.expiry);
        }
        if (message.by !== "") {
            writer.uint32(18).string(message.by);
        }
        for (const v of message.files) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateFileFields();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.expiry = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.by = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.files.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            expiry: isSet(object.expiry) ? BigInt(object.expiry) : 0n,
            by: isSet(object.by) ? globalThis.String(object.by) : "",
            files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.expiry !== 0n) {
            obj.expiry = message.expiry.toString();
        }
        if (message.by !== "") {
            obj.by = message.by;
        }
        if (message.files?.length) {
            obj.files = message.files;
        }
        return obj;
    },
    create(base) {
        return exports.CreateFileFields.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateFileFields();
        message.expiry = object.expiry ?? 0n;
        message.by = object.by ?? "";
        message.files = object.files?.map((e) => e) || [];
        return message;
    },
};
function createBasePollVote() {
    return { postId: new Uint8Array(0), optionId: 0 };
}
exports.PollVote = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.postId.length !== 0) {
            writer.uint32(10).bytes(message.postId);
        }
        if (message.optionId !== 0) {
            writer.uint32(16).int32(message.optionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollVote();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.postId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.optionId = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            postId: isSet(object.postId) ? bytesFromBase64(object.postId) : new Uint8Array(0),
            optionId: isSet(object.optionId) ? globalThis.Number(object.optionId) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.postId.length !== 0) {
            obj.postId = base64FromBytes(message.postId);
        }
        if (message.optionId !== 0) {
            obj.optionId = Math.round(message.optionId);
        }
        return obj;
    },
    create(base) {
        return exports.PollVote.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePollVote();
        message.postId = object.postId ?? new Uint8Array(0);
        message.optionId = object.optionId ?? 0;
        return message;
    },
};
function createBasePollOption() {
    return { optionId: 0, votes: 0n };
}
exports.PollOption = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.optionId !== 0) {
            writer.uint32(8).int32(message.optionId);
        }
        if (message.votes !== 0n) {
            if (BigInt.asIntN(64, message.votes) !== message.votes) {
                throw new globalThis.Error("value provided for field message.votes of type int64 too large");
            }
            writer.uint32(16).int64(message.votes);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollOption();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.optionId = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.votes = reader.int64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            optionId: isSet(object.optionId) ? globalThis.Number(object.optionId) : 0,
            votes: isSet(object.votes) ? BigInt(object.votes) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.optionId !== 0) {
            obj.optionId = Math.round(message.optionId);
        }
        if (message.votes !== 0n) {
            obj.votes = message.votes.toString();
        }
        return obj;
    },
    create(base) {
        return exports.PollOption.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePollOption();
        message.optionId = object.optionId ?? 0;
        message.votes = object.votes ?? 0n;
        return message;
    },
};
function createBasePollResult() {
    return { pollId: new Uint8Array(0), values: [] };
}
exports.PollResult = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pollId.length !== 0) {
            writer.uint32(10).bytes(message.pollId);
        }
        writer.uint32(18).fork();
        for (const v of message.values) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.pollId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag === 16) {
                        message.values.push(reader.int32());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.values.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pollId: isSet(object.pollId) ? bytesFromBase64(object.pollId) : new Uint8Array(0),
            values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => globalThis.Number(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pollId.length !== 0) {
            obj.pollId = base64FromBytes(message.pollId);
        }
        if (message.values?.length) {
            obj.values = message.values.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return exports.PollResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePollResult();
        message.pollId = object.pollId ?? new Uint8Array(0);
        message.values = object.values?.map((e) => e) || [];
        return message;
    },
};
function createBasePollResults() {
    return { results: [] };
}
exports.PollResults = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.results) {
            exports.PollResult.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollResults();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(exports.PollResult.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            results: globalThis.Array.isArray(object?.results) ? object.results.map((e) => exports.PollResult.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.results?.length) {
            obj.results = message.results.map((e) => exports.PollResult.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.PollResults.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePollResults();
        message.results = object.results?.map((e) => exports.PollResult.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCreatePollFields() {
    return { postId: new Uint8Array(0), numOfOpts: 0 };
}
exports.CreatePollFields = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.postId.length !== 0) {
            writer.uint32(10).bytes(message.postId);
        }
        if (message.numOfOpts !== 0) {
            writer.uint32(16).uint32(message.numOfOpts);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreatePollFields();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.postId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.numOfOpts = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            postId: isSet(object.postId) ? bytesFromBase64(object.postId) : new Uint8Array(0),
            numOfOpts: isSet(object.numOfOpts) ? globalThis.Number(object.numOfOpts) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.postId.length !== 0) {
            obj.postId = base64FromBytes(message.postId);
        }
        if (message.numOfOpts !== 0) {
            obj.numOfOpts = Math.round(message.numOfOpts);
        }
        return obj;
    },
    create(base) {
        return exports.CreatePollFields.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreatePollFields();
        message.postId = object.postId ?? new Uint8Array(0);
        message.numOfOpts = object.numOfOpts ?? 0;
        return message;
    },
};
function createBasePollUserVote() {
    return { pollId: new Uint8Array(0), val: 0 };
}
exports.PollUserVote = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pollId.length !== 0) {
            writer.uint32(10).bytes(message.pollId);
        }
        if (message.val !== 0) {
            writer.uint32(16).uint32(message.val);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollUserVote();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.pollId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.val = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pollId: isSet(object.pollId) ? bytesFromBase64(object.pollId) : new Uint8Array(0),
            val: isSet(object.val) ? globalThis.Number(object.val) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pollId.length !== 0) {
            obj.pollId = base64FromBytes(message.pollId);
        }
        if (message.val !== 0) {
            obj.val = Math.round(message.val);
        }
        return obj;
    },
    create(base) {
        return exports.PollUserVote.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePollUserVote();
        message.pollId = object.pollId ?? new Uint8Array(0);
        message.val = object.val ?? 0;
        return message;
    },
};
function createBasePollUserVotes() {
    return { votes: [] };
}
exports.PollUserVotes = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.votes) {
            exports.PollUserVote.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollUserVotes();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.votes.push(exports.PollUserVote.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            votes: globalThis.Array.isArray(object?.votes) ? object.votes.map((e) => exports.PollUserVote.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.votes?.length) {
            obj.votes = message.votes.map((e) => exports.PollUserVote.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.PollUserVotes.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePollUserVotes();
        message.votes = object.votes?.map((e) => exports.PollUserVote.fromPartial(e)) || [];
        return message;
    },
};
function createBasePostReport() {
    return { postId: new Uint8Array(0), sevirity: 0, description: "" };
}
exports.PostReport = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.postId.length !== 0) {
            writer.uint32(10).bytes(message.postId);
        }
        if (message.sevirity !== 0) {
            writer.uint32(16).int32(message.sevirity);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostReport();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.postId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.sevirity = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            postId: isSet(object.postId) ? bytesFromBase64(object.postId) : new Uint8Array(0),
            sevirity: isSet(object.sevirity) ? globalThis.Number(object.sevirity) : 0,
            description: isSet(object.description) ? globalThis.String(object.description) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.postId.length !== 0) {
            obj.postId = base64FromBytes(message.postId);
        }
        if (message.sevirity !== 0) {
            obj.sevirity = Math.round(message.sevirity);
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return exports.PostReport.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostReport();
        message.postId = object.postId ?? new Uint8Array(0);
        message.sevirity = object.sevirity ?? 0;
        message.description = object.description ?? "";
        return message;
    },
};
function createBasePostHashtag() {
    return { name: "", total: 0 };
}
exports.PostHashtag = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.total !== 0) {
            writer.uint32(16).int32(message.total);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostHashtag();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.total = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            total: isSet(object.total) ? globalThis.Number(object.total) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.total !== 0) {
            obj.total = Math.round(message.total);
        }
        return obj;
    },
    create(base) {
        return exports.PostHashtag.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostHashtag();
        message.name = object.name ?? "";
        message.total = object.total ?? 0;
        return message;
    },
};
function createBasePostHashtags() {
    return { hashtags: [] };
}
exports.PostHashtags = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.hashtags) {
            exports.PostHashtag.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostHashtags();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.hashtags.push(exports.PostHashtag.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            hashtags: globalThis.Array.isArray(object?.hashtags)
                ? object.hashtags.map((e) => exports.PostHashtag.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.hashtags?.length) {
            obj.hashtags = message.hashtags.map((e) => exports.PostHashtag.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.PostHashtags.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostHashtags();
        message.hashtags = object.hashtags?.map((e) => exports.PostHashtag.fromPartial(e)) || [];
        return message;
    },
};
function bytesFromBase64(b64) {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
function base64FromBytes(arr) {
    const bin = [];
    arr.forEach((byte) => {
        bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
}
function isSet(value) {
    return value !== null && value !== undefined;
}
